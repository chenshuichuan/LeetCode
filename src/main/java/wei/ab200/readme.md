# 华为A+B套题 200分

| 序号 | 题目                     | 分值 |
|------|--------------------------|------|
| 1    | 士兵过河                 | 200  |
| 2    | 上班之路                 | 200  |
| 3    | 空栈压数                 | 200  |
| 4    | 模拟目录管理             | 200  |
| 5    | 最长的指定瑕疵度的元音子串 | 200  |
| 6    | 数字游戏                 | 200  |
| 7    | 字母组合                 | 200  |
| 8    | 计算疫情扩散时间         | 200  |
| 9    | 导师请吃火锅             | 200  |
| 10   | 跳马                     | 200  |
| 11   | 最大社交距离             | 200  |
| 12   | 通过软盘拷贝文件         | 200  |
| 13   | 狼羊过河                 | 200  |
| 14   | 二叉树计算               | 200  |
| 15   | 找单词                   | 200  |
| 16   | 最长方连续方波信号       | 200  |
| 17   | 电脑病毒感染             | 200  |


## 1. 士兵过河
以下是您提供的题目的复述：

---

### 题目描述

一支N个士兵的军队正在趁夜色逃亡，途中遇到一条急的大河。敌军在T时长后到达河面，没到对岸的士兵都会被消灭。现在军队只找到了1只小船，这船最多能同时坐上2个士兵。

规则如下：
1. 当1个士兵划船过河，用时为 a[i]，其中 0 <= i < N。
2. 当2个士兵坐船同时划船过河时，用时为 max(a[i], a[j])，即两士兵中用时最长的那个。
3. 如果士兵下河游泳，则会被湍急水流直接带走，算作死亡。

请给出一种解决方案，保证存活的士兵最多，且过河用时最短。

### 输入描述

第一行：N 表示士兵数（0 < N < 1,000,000）

第二行：T 表示敌军到达时长（0 < T < 100,000,000）

第三行：a[0] a[1] ... a[N-1]

a[] 表示每个士兵的过河时长。（10 <= a[i] < 100；0 <= i < N）

### 备注

1. 两个士兵的同时划船时，如果划速不同则会导致船原地转圈圈；所以为保持两个士兵划速相同，则需要向划得慢的士兵看齐。
2. 两个士兵坐船时，重量增加吃水加深，水的阻力增大；同样的力量划船速度会变慢。
3. 由于河水湍急大量的力用来抵消水流的阻力，所以2)中过河用时不是 a[i]*2，而是 a[i]*10。

### 输出描述

第一行："最多存活士兵数" "最短用时"

### 示例 1

**输入**
```
5
43
12 13 15 20 50
```
**输出**
```
3 40
```
---

## 2. 上班之路
### 题目描述

Jungle 生活在美丽的蓝鲸城，大马路都是方方正正的，但是每天马路的封闭情况都不一样。地图由以下元素组成：

- `.` — 空地，可以达到
- `*` — 路障，不可达到
- `S` — Jungle 的家
- `T` — 公司

其中我们会限制 Jungle 拐弯的次数，同时 Jungle 可以清除给定个数的路障。现在你的任务是计算 Jungle 是否可以从家里出发到达公司。

#### 输入描述

输入的第一行包含两个整数 \( t \) 和 \( c \)，其中 \( 0 \leq t \leq 100 \) 表示可以拐弯的次数，\( c \) 表示可以清除的路障个数。

输入的第二行包含两个整数 \( n \) 和 \( m \)，其中 \( 1 \leq n, m \leq 100 \)，表示地图的大小。

接下来是 \( n \) 行包含 \( m \) 个字符的地图。 \( n \) 和 \( m \) 可能不一样大。我们保证地图里有 `S` 和 `T`。

#### 输出描述

输出是否可以从家里出发到达公司，如果可以则输出 `YES`，否则输出 `NO`。

#### 示例 1

**输入**
```
2 0
5 5
..S..
*****
T....
*****
.....
```
**输出**
```
YES
```
---

## 3. 空栈压数
### 题目描述

向一个空栈压入正整数，每当压入一个整数时，执行以下规则（设：栈顶至栈底整数依次为 n1, n2, ..., nx，其中 n1 为最新压入的整数）：

1. 如果 n1 = n2，则 n1, n2 全部出栈，压入新数据 m (m = 2 * n1)。
2. 如果 n1 = n2 + ... + ny 的范围为 3 ≤ n ≤ y，则 n1, n2, ..., ny 全部出栈，压入新数据 m (m = 2 * n1)。
3. 如果上述规则均不满足，则不做操作。

例如：依次向栈中压入 6, 1, 2, 3：
1. 当压入 2 时，栈顶至栈底依次为 2, 1, 6。
2. 当压入 3 时，3 = 2 + 1，3, 2, 1 全部出栈，重新入栈整数 6，此时栈顶至栈底依次为 6, 6。6 = 6，两个 6 全部出栈，压入 12，最终栈中只剩元素 12。

#### 输入描述
使用单个空格隔开的正整数的字符串 Q，如“5678”，左边的数字先入栈。正整数大小为 [1, 2^31 - 1]，正整数个数为 [1, 1000]。

#### 输出描述
最终栈中存留的元素值，元素值使用单个空格隔开，从左至右依次为栈顶至栈底的数字。

#### 示例 1
**输入**
```
10 20 50 80 1 1
```
**输出**
```
2 160
```

#### 示例 2
**输入**
```
5 10 20 50 85 1
```
**输出**
```
1 170
```

---
### 代码解释

1. **读取输入**：将输入字符串分割成整数数组。
2. **处理栈**：遍历每个整数，将其压入栈，并调用 `processStack` 方法进行处理。
3. **处理栈逻辑**：
    - 检查栈顶元素和下一个元素是否满足条件2（即 n1 = n2 + ... + ny）。
    - 如果满足条件2，则将这些元素全部出栈，并压入新数据 m (m = 2 * n1)。
    - 否则，检查是否满足条件1（即 n1 = n2），如果满足则将这两个元素出栈，并压入新数据 m (m = 2 * n1)。
4. **输出结果**：遍历栈中的所有元素并输出。

